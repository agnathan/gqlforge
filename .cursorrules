# Cursor Rules for gqlforge

## Project Overview

This is a TypeScript library for working with GraphQL schemas using a context-free grammar (CFG) representation. The project uses a plugin architecture with parsers, transformers, and generators.

## Reference Documentation

**CRITICAL: Always use `src/grammar.ts` as the authoritative reference** when implementing GraphQL-related functionality. This file contains the complete GraphQL Grammar Specification (September 2025 Edition) and defines:

- All grammar element types (Terminal, NonTerminal, Sequence, OneOf, Optional, List)
- The complete GraphQL grammar structure following the specification
- Helper functions for constructing grammar elements
- The canonical `GraphQLGrammar` object

When implementing parsers, generators, or transformers:
1. **Always reference `src/grammar.ts`** to understand the grammar structure
2. Follow the specification sections (3.3 Schema, 3.5 Scalars, 3.6 Objects, etc.)
3. Use the helper functions (`T()`, `NT()`, `Seq()`, `Or()`, `Opt()`, `Lst()`) when constructing grammar elements
4. Ensure implementations match the grammar structure defined in `src/grammar.ts`

## Testing Architecture

### Fixture-Based Testing

All tests use fixture-based testing organized by plugin type:

```
tests/
  fixtures/
    parsers/{parser-name}/
      valid/          # Valid input schemas
      invalid/        # Invalid input schemas
      expected/       # Expected grammar outputs
      validation/    # Expected validation results
      linting/        # Expected linting results
    
    transformers/{transformer-name}/
      input/          # Input schemas/grammars
      expected/       # Expected outputs
      config/         # Transformer options
      validation/     # Expected validation results
      linting/        # Expected linting results
    
    generators/{generator-name}/
      input/          # Input grammars
      expected/       # Expected outputs
      config/         # Generator options
      validation/     # Expected validation results
      linting/        # Expected linting results
```

### Test Organization

Tests are organized by plugin type, mirroring the fixture structure:

```
tests/
  parsers/
    {parser-name}.test.ts
  transformers/
    {transformer-name}.test.ts
  generators/
    {generator-name}.test.ts
```

### Critical Testing Rules

1. **ALL tests that generate GraphQL MUST validate and lint the output**
   - Use `expectValidGraphQL()` helper from `tests/helpers/schema-validator.ts`
   - This ensures generated GraphQL is both valid (spec-compliant) and follows best practices
   - Tests will fail if validation/linting errors occur

2. **Fixture Loading**
   - Use `loadParserFixtures()`, `loadTransformerFixtures()`, or `loadGeneratorFixtures()`
   - Import from `tests/helpers/fixtures.ts`
   - Fixtures are organized by plugin name

3. **Validation Requirements**
   - Generator tests: Always validate generated GraphQL
   - Transformer tests: Validate GraphQL generated from transformed grammar
   - Parser tests: Validate GraphQL generated from parsed grammar (round-trip)

4. **Error Capture for Regression**
   - Use `captureValidationErrors()` to save validation results as fixtures
   - Store expected validation/linting results in `validation/` and `linting/` directories
   - Compare actual vs expected using `validateAndLintGraphQL()` with fixture path

### Helper Functions

**Fixture Loading:**
```typescript
import { loadGeneratorFixtures } from '../helpers/fixtures';
const fixtures = loadGeneratorFixtures('json');
const input = fixtures.input('simple-grammar.json');
```

**GraphQL Validation:**
```typescript
import { expectValidGraphQL } from '../helpers/schema-validator';

// Required: Validate generated GraphQL
await expectValidGraphQL(generatedSDL, undefined, {
  failOnWarnings: false,  // Warnings OK, errors not OK
});

// With expected results fixture:
await expectValidGraphQL(
  generatedSDL,
  'generators/json/validation/simple-valid.json',
  { acceptableWarnings: ['@graphql-eslint/require-description'] }
);
```

**Validation Result Capture:**
```typescript
import { captureValidationErrors } from '../helpers/schema-validator';

const results = await captureValidationErrors(
  schemaSDL,
  'generators/json/validation/simple-valid.json',
  { updateFixture: true, acceptableWarnings: [...] }
);
```

### Test Patterns

**Generator Test Pattern:**
```typescript
describe('{generator-name} generator', () => {
  const fixtures = loadGeneratorFixtures('{generator-name}');
  
  it('generates valid GraphQL', async () => {
    const input = fixtures.input('simple-grammar.json');
    const output = generator.generate(input);
    
    // REQUIRED: Validate generated GraphQL
    await expectValidGraphQL(output, undefined, {
      failOnWarnings: false,
    });
  });
});
```

**Transformer Test Pattern:**
```typescript
describe('{transformer-name} transformer', () => {
  const fixtures = loadTransformerFixtures('{transformer-name}');
  
  it('transforms and generates valid GraphQL', async () => {
    const options = fixtures.config('options.json');
    const result = registry.transform(grammar, ['{transformer-name}'], {
      '{transformer-name}': options,
    });
    
    // Generate GraphQL from transformed grammar
    const generatedSDL = registry.generate(result.grammar, 'graphql-sdl');
    
    // REQUIRED: Validate generated GraphQL
    await expectValidGraphQL(generatedSDL.output as string, undefined, {
      failOnWarnings: false,
    });
  });
});
```

**Parser Test Pattern:**
```typescript
describe('{parser-name} parser', () => {
  const fixtures = loadParserFixtures('{parser-name}');
  
  it('parses and generates valid GraphQL', async () => {
    const schemaSDL = fixtures.valid('simple.graphql');
    const parsedGrammar = parser.parse(schemaSDL);
    
    // Generate GraphQL from parsed grammar
    const generatedSDL = registry.generate(parsedGrammar, 'graphql-sdl');
    
    // REQUIRED: Validate generated GraphQL (round-trip validation)
    await expectValidGraphQL(generatedSDL.output as string, undefined, {
      failOnWarnings: false,
    });
  });
});
```

### Validation Result Fixture Format

```json
{
  "isValid": true,
  "errors": [],
  "warnings": [
    {
      "message": "Type 'User' is missing a description",
      "line": 2,
      "ruleId": "@graphql-eslint/require-description"
    }
  ],
  "acceptableWarnings": ["@graphql-eslint/require-description"]
}
```

### Best Practices

1. **Always validate GraphQL outputs** - No exceptions
2. **Use fixtures for test data** - Don't inline test data
3. **Organize by plugin** - Keep fixtures and tests together by plugin type
4. **Capture validation results** - Store expected results for regression testing
5. **Document acceptable warnings** - Use `acceptableWarnings` in fixtures
6. **Fail on errors, not warnings** - Use `failOnWarnings: false` unless specifically testing for warnings
7. **Update fixtures intentionally** - Use `updateFixture: true` only when intentionally updating expected results

### Adding New Tests

When adding a new test:

1. Create fixtures in appropriate plugin directory
2. Use fixture loading helpers
3. **Always validate GraphQL outputs** using `expectValidGraphQL()`
4. Store expected validation results if testing specific error scenarios
5. Follow the test patterns above

### Running Tests

```bash
npm test                    # Run all tests
npm test -- --run          # Run once (no watch)
npm test -- {pattern}      # Run specific tests
npm test -- --ui           # UI mode
npm test -- -t {TEST_ID}   # Run test by ID (e.g., GEN-GSDL-001)
```

### Test IDs

Every test has a unique ID for easy reference in documentation and when communicating with AI agents.

**Format**: `{TYPE}-{PLUGIN}-{NUMBER}`
- **TYPE**: `GEN` (generator), `TRANS` (transformer), `PARSE` (parser), `VALID` (validation)
- **PLUGIN**: Short plugin identifier (e.g., `GSDL` for graphql-sdl, `AF` for add-field)
- **NUMBER**: Sequential test number within the plugin (001, 002, etc.)

**Examples**:
- `GEN-GSDL-001`: Generator graphql-sdl test #1 - "generates schema definition with root operation types"
- `TRANS-AF-001`: Transformer add-field test #1 - "adds email field to User type"
- `PARSE-GSDL-001`: Parser graphql-sdl test #1 - "parses simple schema"

**Usage**:
- Reference tests in documentation: "See test `GEN-GSDL-001` for schema definition generation"
- Run specific test: `npm test -- -t GEN-GSDL-001`
- Communicate with AI agents: "Fix the issue in test `GEN-GSDL-001`"

Test IDs are registered in `tests/helpers/test-ids.ts` and appear in test names: `[GEN-GSDL-001] generates schema definition...`

### Test Reporting

All tests automatically generate detailed reports in `test-reports/{datetime}/{test-file}/{test-id}-{status}.json`.

**Report Structure:**
- `test-reports/` - Root directory (gitignored)
- `{datetime}/` - Directory named with ISO datetime (e.g., `2025-12-07T21-04-32`)
- `{test-file}/` - Directory named after test file (e.g., `graphql-sdl`)
- `{test-id}-{status}.json` - Report file (e.g., `GEN-GSDL-001-PASSED.json`)

**Report Contents:**
- Test ID and description
- Status (PASSED/FAILED)
- Timestamp
- Test file path
- Input data
- Expected output
- Actual output
- Errors (if failed)
- Validation errors and warnings
- Validation result summary

**Usage:**
```typescript
import { initTestReport, reportTestPassed, reportTestFailed } from "../helpers/report-test";

it(`[${TEST_ID}] test description`, async () => {
  const input = fixtures.input("input.json");
  const expected = fixtures.expected("expected.graphql");
  
  initTestReport({
    testId: TEST_ID,
    description: "test description",
    input,
    expectedOutput: expected,
  });
  
  const output = generator.generate(input);
  
  try {
    const validationResult = await expectValidGraphQL(output, undefined, {
      expectedFixture: expected,
      testId: TEST_ID,
    });
    
    reportTestPassed({
      testId: TEST_ID,
      description: "test description",
      input,
      expectedOutput: expected,
      actualOutput: output,
      validationResult,
    });
  } catch (error) {
    reportTestFailed(
      {
        testId: TEST_ID,
        description: "test description",
        input,
        expectedOutput: expected,
        actualOutput: output,
      },
      error instanceof Error ? error : new Error(String(error))
    );
    throw error;
  }
});
```

### Viewing Test Reports

View pretty-printed test reports using the test:report script:

```bash
npm run test:report <TEST_ID>
```

**Example:**
```bash
npm run test:report GEN-GSDL-001
```

This will display:
- Test status (PASSED/FAILED)
- Test description and metadata
- Input data
- Expected output
- Actual output
- Validation errors and warnings
- Validation summary

If multiple reports exist for the same test ID, the most recent one is shown by default.

### Preparing Tests ("Prep Test")

When asked to "prep test" or "prepare test" with a test ID (e.g., "prep test GEN-GSDL-002"), the following steps must be performed to set up proper test reporting:

1. **Add Test Report Initialization**
   - Add `initTestReport()` call immediately after loading fixtures
   - Include: `testId`, `description`, `input`, `expectedOutput`

2. **Add GraphQL Validation**
   - Replace any commented-out validation with active `expectValidGraphQL()` call
   - Include all required options:
     - `failOnWarnings: false`
     - `expectedFixture: expected`
     - `compareMode: "semantic"`
     - `saveOutput` (conditional on `SAVE_TEST_OUTPUTS` env var)
     - `pluginType` and `pluginName`
     - `testId: TEST_ID`

3. **Add Success Reporting**
   - Wrap validation in try/catch block
   - Call `reportTestPassed()` in the try block with:
     - `testId`, `description`, `input`, `expectedOutput`, `actualOutput`, `validationResult`

4. **Add Error Handling & Failure Reporting**
   - In catch block, call `reportTestFailed()` with:
     - `testId`, `description`, `input`, `expectedOutput`, `actualOutput`, `validationResult`
     - Error object (properly typed)
   - Re-throw the error to fail the test

5. **Add Required Imports**
   - Import `initTestReport`, `reportTestPassed`, `reportTestFailed` from `../helpers/report-test`
   - Import `SchemaCheckResult` type from `../helpers/schema-validator`

**Example Pattern:**
```typescript
it(`[${TEST_ID}] test description`, async () => {
  const input = fixtures.input("input.json") as Grammar;
  const expected = fixtures.expected("expected.graphql");
  
  // Initialize test report context
  initTestReport({
    testId: TEST_ID,
    description: "test description",
    input,
    expectedOutput: expected,
  });
  
  const output = generator.generate(input, options);

  expect(typeof output).toBe("string");
  expect(output.length).toBeGreaterThan(0);

  // REQUIRED: Validate generated GraphQL and compare with expected fixture
  // Validation errors will cause the test to fail and be reported
  let validationResult: SchemaCheckResult | undefined;
  try {
    validationResult = await expectValidGraphQL(output, undefined, {
      failOnWarnings: false,
      expectedFixture: expected,
      compareMode: "semantic",
      saveOutput:
        process.env.SAVE_TEST_OUTPUTS === "true"
          ? "expected.graphql"
          : false,
      pluginType: "generators",
      pluginName: "graphql-sdl",
      testId: TEST_ID,
    });
    
    // Report test passed
    reportTestPassed({
      testId: TEST_ID,
      description: "test description",
      input,
      expectedOutput: expected,
      actualOutput: output,
      validationResult,
    });
  } catch (error) {
    // Report test failed
    reportTestFailed(
      {
        testId: TEST_ID,
        description: "test description",
        input,
        expectedOutput: expected,
        actualOutput: output,
        validationResult,
      },
      error instanceof Error ? error : new Error(String(error))
    );
    throw error;
  }
});
```

**Reference Implementation:**
- See `tests/generators/graphql-sdl.test.ts` test `GEN-GSDL-001` or `GEN-GSDL-002` for complete examples

## Code Style

- Use TypeScript strict mode
- Prefer explicit types over `any`
- Use async/await for async operations
- Follow existing patterns for consistency

## Plugin Architecture

- **Parsers**: Convert external formats (e.g., GraphQL SDL) to Grammar
- **Transformers**: Transform Grammar to Grammar
- **Generators**: Convert Grammar to external formats (e.g., JSON, GraphQL SDL)

All plugins are registered in `PluginRegistry` and follow consistent interfaces defined in `src/plugins/types.ts`.

